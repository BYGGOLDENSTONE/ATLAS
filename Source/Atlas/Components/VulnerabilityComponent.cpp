#include "VulnerabilityComponent.h"
#include "Engine/World.h"
#include "TimerManager.h"
#include "DrawDebugHelpers.h"
#include "GameFramework/Character.h"

UVulnerabilityComponent::UVulnerabilityComponent()
{
    PrimaryComponentTick.bCanEverTick = true;
    InitializeTierConfigs();
}

void UVulnerabilityComponent::BeginPlay()
{
    Super::BeginPlay();
    InitializeTierConfigs();
}

void UVulnerabilityComponent::InitializeTierConfigs()
{
    // Stunned Tier (Yellow) - Light vulnerability
    StunnedConfig.MaxCriticalHits = 1;
    StunnedConfig.DamageMultiplier = 2.0f;
    StunnedConfig.Duration = 2.0f;
    StunnedConfig.IndicatorColor = FLinearColor(1.0f, 1.0f, 0.0f); // Yellow
    StunnedConfig.RecoveryTime = 0.3f;

    // Crippled Tier (Orange) - Medium vulnerability
    CrippledConfig.MaxCriticalHits = 3;
    CrippledConfig.DamageMultiplier = 4.0f;
    CrippledConfig.Duration = 3.0f;
    CrippledConfig.IndicatorColor = FLinearColor(1.0f, 0.5f, 0.0f); // Orange
    CrippledConfig.RecoveryTime = 0.5f;

    // Exposed Tier (Red) - Heavy vulnerability
    ExposedConfig.MaxCriticalHits = 5;
    ExposedConfig.DamageMultiplier = 8.0f;
    ExposedConfig.Duration = 4.0f;
    ExposedConfig.IndicatorColor = FLinearColor(1.0f, 0.0f, 0.0f); // Red
    ExposedConfig.RecoveryTime = 0.7f;
}

void UVulnerabilityComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)
{
    Super::TickComponent(DeltaTime, TickType, ThisTickFunction);

    if (VulnerabilityState.CurrentTier != EVulnerabilityTier::None)
    {
        VulnerabilityState.TimeRemaining = FMath::Max(0.0f, VulnerabilityState.TimeRemaining - DeltaTime);
        
        if (bShowDebugIndicators)
        {
            DrawDebugIndicator();
        }
    }

    if (VulnerabilityState.bHasIFrames)
    {
        VulnerabilityState.IFrameTimeRemaining = FMath::Max(0.0f, VulnerabilityState.IFrameTimeRemaining - DeltaTime);
    }
}

void UVulnerabilityComponent::ApplyVulnerabilityTier(EVulnerabilityTier Tier, float OverrideDuration)
{
    if (Tier == EVulnerabilityTier::None)
    {
        EndVulnerability();
        return;
    }

    // Get config for the tier
    FVulnerabilityTierConfig Config = GetTierConfig(Tier);
    
    // Set state
    VulnerabilityState.CurrentTier = Tier;
    VulnerabilityState.RemainingCriticalHits = Config.MaxCriticalHits;
    VulnerabilityState.TimeRemaining = (OverrideDuration > 0.0f) ? OverrideDuration : Config.Duration;

    // Clear and set timer
    GetWorld()->GetTimerManager().ClearTimer(VulnerabilityTimerHandle);
    GetWorld()->GetTimerManager().SetTimer(
        VulnerabilityTimerHandle,
        this,
        &UVulnerabilityComponent::HandleVulnerabilityTimeout,
        VulnerabilityState.TimeRemaining,
        false
    );

    // Update combat state
    UCombatComponent* CombatComp = GetOwner()->FindComponentByClass<UCombatComponent>();
    if (CombatComp)
    {
        CombatComp->AddCombatStateTag(FGameplayTag::RequestGameplayTag("Combat.State.Vulnerable"));
    }

    // Broadcast event
    OnVulnerabilityTierApplied.Broadcast(Tier, Config.MaxCriticalHits, VulnerabilityState.TimeRemaining);

    UE_LOG(LogTemp, Warning, TEXT("%s applied %s vulnerability! Max Hits: %d, Duration: %.1f, Multiplier: %.1fx"),
        *GetOwner()->GetName(),
        *UEnum::GetValueAsString(Tier),
        Config.MaxCriticalHits,
        VulnerabilityState.TimeRemaining,
        Config.DamageMultiplier);
}

void UVulnerabilityComponent::OnCriticalHitLanded()
{
    if (VulnerabilityState.CurrentTier == EVulnerabilityTier::None)
        return;

    VulnerabilityState.RemainingCriticalHits--;
    
    OnVulnerabilityHitTaken.Broadcast(VulnerabilityState.RemainingCriticalHits, VulnerabilityState.CurrentTier);

    UE_LOG(LogTemp, Warning, TEXT("%s took critical hit! Remaining hits: %d"),
        *GetOwner()->GetName(),
        VulnerabilityState.RemainingCriticalHits);

    if (VulnerabilityState.RemainingCriticalHits <= 0)
    {
        EndVulnerability();
    }
}

FVulnerabilityTierConfig UVulnerabilityComponent::GetTierConfig(EVulnerabilityTier Tier) const
{
    switch (Tier)
    {
        case EVulnerabilityTier::Stunned:
            return StunnedConfig;
        case EVulnerabilityTier::Crippled:
            return CrippledConfig;
        case EVulnerabilityTier::Exposed:
            return ExposedConfig;
        default:
            return FVulnerabilityTierConfig();
    }
}

FLinearColor UVulnerabilityComponent::GetCurrentTierColor() const
{
    return GetTierConfig(VulnerabilityState.CurrentTier).IndicatorColor;
}

float UVulnerabilityComponent::GetDamageMultiplier() const
{
    if (VulnerabilityState.CurrentTier != EVulnerabilityTier::None)
    {
        return GetTierConfig(VulnerabilityState.CurrentTier).DamageMultiplier;
    }
    return 1.0f;
}

void UVulnerabilityComponent::DrawDebugIndicator()
{
    if (!GetWorld() || VulnerabilityState.CurrentTier == EVulnerabilityTier::None)
        return;

    FVector OwnerLocation = GetOwner()->GetActorLocation();
    FVector IndicatorLocation = OwnerLocation + FVector(0, 0, IndicatorHeight);
    
    FLinearColor Color = GetCurrentTierColor();
    FColor DrawColor = Color.ToFColor(true);

    // Draw tier indicator sphere
    DrawDebugSphere(
        GetWorld(),
        IndicatorLocation,
        IndicatorSize,
        12,
        DrawColor,
        false,
        -1.0f,
        0,
        2.0f
    );

    // Draw hit counter text
    FString TierText = FString::Printf(TEXT("%s\nHits: %d/%d\nTime: %.1f"),
        *UEnum::GetValueAsString(VulnerabilityState.CurrentTier),
        VulnerabilityState.RemainingCriticalHits,
        GetTierConfig(VulnerabilityState.CurrentTier).MaxCriticalHits,
        VulnerabilityState.TimeRemaining);

    DrawDebugString(
        GetWorld(),
        IndicatorLocation + FVector(0, 0, IndicatorSize + 10),
        TierText,
        nullptr,
        DrawColor,
        0.0f,
        true,
        1.2f
    );

    // Draw pulsing ring effect
    float PulseScale = 1.0f + FMath::Sin(GetWorld()->GetTimeSeconds() * 4.0f) * 0.2f;
    DrawDebugCircle(
        GetWorld(),
        OwnerLocation + FVector(0, 0, 10),
        50.0f * PulseScale,
        32,
        DrawColor,
        false,
        -1.0f,
        0,
        2.0f,
        FVector(0, 1, 0),
        FVector(1, 0, 0)
    );
}

// Legacy support functions
void UVulnerabilityComponent::ApplyVulnerability(int32 Charges, float Duration)
{
    // Map old charge system to tier system
    EVulnerabilityTier Tier;
    if (Charges <= 1)
        Tier = EVulnerabilityTier::Stunned;
    else if (Charges <= 3)
        Tier = EVulnerabilityTier::Crippled;
    else
        Tier = EVulnerabilityTier::Exposed;

    ApplyVulnerabilityTier(Tier, Duration);
}

void UVulnerabilityComponent::ConsumeCharge()
{
    OnCriticalHitLanded();
}

void UVulnerabilityComponent::EndVulnerability()
{
    if (VulnerabilityState.CurrentTier == EVulnerabilityTier::None)
        return;

    EVulnerabilityTier EndedTier = VulnerabilityState.CurrentTier;
    
    VulnerabilityState.CurrentTier = EVulnerabilityTier::None;
    VulnerabilityState.RemainingCriticalHits = 0;
    VulnerabilityState.TimeRemaining = 0.0f;

    GetWorld()->GetTimerManager().ClearTimer(VulnerabilityTimerHandle);

    UCombatComponent* CombatComp = GetOwner()->FindComponentByClass<UCombatComponent>();
    if (CombatComp)
    {
        CombatComp->RemoveCombatStateTag(FGameplayTag::RequestGameplayTag("Combat.State.Vulnerable"));
    }

    OnVulnerabilityTierEnded.Broadcast(EndedTier);

    UE_LOG(LogTemp, Warning, TEXT("%s vulnerability ended"), *GetOwner()->GetName());
}

void UVulnerabilityComponent::HandleVulnerabilityTimeout()
{
    EndVulnerability();
}

void UVulnerabilityComponent::StartIFrames(float Duration)
{
    if (!bEnableIFrames)
        return;

    float IFrameTime = (Duration <= 0.0f) ? IFrameDuration : Duration;
    
    VulnerabilityState.bHasIFrames = true;
    VulnerabilityState.IFrameTimeRemaining = IFrameTime;

    GetWorld()->GetTimerManager().ClearTimer(IFrameTimerHandle);
    GetWorld()->GetTimerManager().SetTimer(
        IFrameTimerHandle,
        this,
        &UVulnerabilityComponent::HandleIFrameTimeout,
        IFrameTime,
        false
    );

    OnIFramesStarted.Broadcast();

    UE_LOG(LogTemp, Warning, TEXT("%s gained i-frames for %.2f seconds"), 
        *GetOwner()->GetName(), IFrameTime);
}

void UVulnerabilityComponent::EndIFrames()
{
    if (!VulnerabilityState.bHasIFrames)
        return;

    VulnerabilityState.bHasIFrames = false;
    VulnerabilityState.IFrameTimeRemaining = 0.0f;

    GetWorld()->GetTimerManager().ClearTimer(IFrameTimerHandle);

    OnIFramesEnded.Broadcast();

    UE_LOG(LogTemp, Warning, TEXT("%s i-frames ended"), *GetOwner()->GetName());
}

void UVulnerabilityComponent::HandleIFrameTimeout()
{
    EndIFrames();
}