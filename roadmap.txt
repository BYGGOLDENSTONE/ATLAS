# Roadmap Overview (testable phases)

**P0. Project Setup & Upgrade (UE 5.5)**
**P1. Core Gameplay Tags + Data Assets + Damage Pipeline**
**P2. Basic Punch (LMB): Anim‑Driven Hitboxes**
**P3. Block (hold Space): 40% Reduction, Exceptions via Tags**
**P4. Parry (RMB) + Vulnerability (Charges) + Optional i‑frames**
**P5. Heavy Punch Special + Ragdoll + Wall‑Bump Extra Stagger/Dmg**
**P6. Stagger System + Light Poise**
**P7. Focus Mode Targeting (Q) + Interactables Framework + Vent + Valve**
**P8. Combat State + Smart Soft Lock Camera**
**P9. Enemy AI (BT/BB): Basic → Combos → Soul Attack → Catch Special → Interactables**
**P10. Polish & Debugging: Hit‑pause, Camera Shake, Motion Warping, Tuning Tools**

Each phase below includes: **Goals, Deliverables, DoD (definition of done), AI Agent Steps, In‑Engine Setup, Tests, Changelog entry template**.

---

## P0. Project Setup & Upgrade (UE 5.5)

**Goal:** Create a clean 5.5 project skeleton, enable required plugins, input mapping, folders, coding standards.

**Deliverables**

* UE 5.5 C++ project compiles & runs.
* Plugins enabled: *Enhanced Input, Gameplay Tags, AIModule, EQS, Niagara (optional), Motion Warping (optional), CommonUI (optional)*.
* Folder structure created.
* Input Mapping Context with actions: Move, Look, Attack(LMB), Parry(RMB), Block(Space Hold), Focus(Q Hold), Heavy(E or Middle Mouse), LockCancel(Mouse move large, implemented later).

**DoD**

* PIE world runs, character can move/look (no combat yet).
* `changelog.md` created with Phase P0 entry.

**AI Agent – Step‑by‑Step**

1. **Upgrade to 5.5:**

   * Open `.uproject` in UE 5.5, let it update.
   * Regenerate project files, build in IDE. Resolve any 5.3→5.5 deprecations (prefer Enhanced Input v2 API calls; avoid legacy `UInputComponent::BindAction`).
2. **Enable Plugins:** Edit → Plugins → search & enable above list → restart editor.
3. **Project Modules:** Ensure `AIModule`, `GameplayTags`, `EnhancedInput`, `NavigationSystem`, `GameplayTasks` in `Build.cs`.
4. **Folder Layout (Content):**
   `Content/Characters/Player`, `.../Enemy`, `.../Animations`, `.../Blueprints`, `.../DataAssets`, `.../UI`, `.../Interactables`, `.../FX`.
   (Source mirrors with Modules: `Source/GameName/…`)
5. **Input (Enhanced Input):**

   * Create `IMC_Combat` (Input Mapping Context).
   * Create `IA_Move`, `IA_Look` (Axis2D), `IA_Attack_LMB`, `IA_Parry_RMB`, `IA_Block_Space_Hold`, `IA_Focus_Q_Hold`, `IA_Heavy_E`.
   * Apply `IMC_Combat` at BeginPlay in PlayerController.
6. **Templates:** Create base `AGameCharacterBase` (C++), `APlayerCharacter` (inherits), `AEnemyCharacter` (inherits). Add `USpringArmComponent` + `UCameraComponent`.

**In‑Engine Setup**

* Project Settings → Input → Ensure Enhanced Input Subsystem for Local Player is active (it is by default in 5.5).
* World Settings → GameMode → set your custom GM/PC/Pawn/HUD.

**Tests**

* Create a simple level with floor and `APlayerCharacter`. PIE: WASD move, mouse look.
* Verify IMC applies (print debug when pressing LMB/RMB/Space/Q/E).

**Changelog.md (append)**

```
## P0 – Project Setup (UE 5.5)
- Upgraded to UE 5.5. Enabled Enhanced Input, Gameplay Tags, AIModule, EQS, Motion Warping.
- Established folder structure and input actions.
- Simple pawn with camera verified in PIE.
Known Issues: None.
```

---

## P1. Core Gameplay Tags + Data Assets + Damage Pipeline

**Goal:** Data‑driven damage & states without GAS. Central place to compute final damage, tags for rules.

**Deliverables**

* `UCombatComponent`, `UHealthComponent`, `UDamageCalculator` (static funcs).
* `UAttackDataAsset` (BaseDamage, Tags, Knockback, PlayRateCurve optional).
* Gameplay Tags taxonomy created.

**DoD**

* Calling `ApplyDamage()` from anywhere routes through `UDamageCalculator` and affects `UHealthComponent`.
* Tags influence blockability/parryability later.

**AI Agent – Steps**

1. **Gameplay Tags:** Add `DefaultGameplayTags.ini` categories:
   `Attack.Basic, Attack.Heavy, Attack.Soul, Attack.Blockable, Attack.Unblockable, Attack.Parryable, Attack.Unparryable, Effect.Stagger, State.Vulnerable, Archetype.Mage`.
2. **Components (C++):**

   * `UHealthComponent`: `Health`, `OnDamaged`, `OnDeath`.
   * `UCombatComponent`: stores current AttackData, exposes `RequestAttack(FGameplayTag AttackTag)`, handles cooldown map.
   * `UDamageCalculator`:

     ```
     FinalDamage = BaseDamage
                 * VulnerabilityMultiplierIfAny
                 * BlockMultiplierIfAny
                 * OtherModifierFromTags
     ```
   * Make everything **BP‑editable** (`EditAnywhere`) and **event‑driven** with delegates.
3. **Data Assets:** `UAttackDataAsset` with fields for damage, tags, poise damage (used later), hit pause (used later).
4. **Collision Channels:** Add custom channel `Hitbox` if desired; otherwise use `ECC_GameTraceChannel1`.

**In‑Engine Setup**

* Project Settings → Gameplay Tags → Import/Add from ini.
* Create sample `DA_Attack_Basic` (5 dmg, `Attack.Basic|Attack.Blockable|Attack.Parryable`), `DA_Attack_Heavy`, `DA_Attack_Soul`.

**Tests**

* Blueprint call from Player: `CombatComponent->ApplyTestDamage(Target, DA_Attack_Basic)` and verify health decreases by 5 in a print log.

**Changelog**

```
## P1 – Tags, Data, Damage
- Added Gameplay Tags and Attack Data Assets.
- Implemented HealthComponent, CombatComponent, DamageCalculator.
- Verified damage application via test call.
```

---

## P2. Basic Punch (LMB): Anim‑Driven Hitboxes

**Goal:** Animation notifies spawn fist spheres (radius 15) to detect hits; range “comes from animation”.

**Deliverables**

* `AHitboxActor` (pooled or transient) or `UHitboxComponent` attached to hand sockets.
* Anim Notifies: `AN_AttackWindowStart`, `AN_AttackWindowEnd` (or a NotifyState).
* Per‑attack **Hit Registry** (prevent multi‑hit on same target during one window).
* Knockback 100 on hit.

**DoD**

* Press LMB → plays montage; active frames spawn hitbox; hitting enemy deals 5 dmg + 100 knockback. No self‑hits. No multi‑hits.

**AI Agent – Steps**

1. **Sockets:** Ensure `hand_r`, `hand_l` sockets on skeleton.
2. **Hitboxes:** Implement `AHitboxActor` (SphereComponent, radius 15). On overlap begin → ask `UCombatComponent` to resolve hit (query tags; ignore owner/team).
3. **Registry:** For each attack instance, maintain `TSet<TWeakObjectPtr<AActor>> AlreadyHit`.
4. **Montage & Notifies:** Create `AM_Jab` with notifies to `Start/End` windows.
5. **Knockback:** Apply impulse/launch or movement offset (keep simple add impulse in character movement).

**In‑Engine Setup**

* Create `AM_Jab` for player and a temp for enemy (same asset allowed). Add notifies at appropriate frames.
* Bind IA\_Attack\_LMB → `CombatComponent->RequestAttack(Attack.Basic)` → plays `AM_Jab`.

**Tests**

* Place an enemy dummy with `UHealthComponent`.
* Step forward during montage to reach 150–200 effective range; verify hits only during window.
* Confirm no repeated hits during one window.

**Changelog**

```
## P2 – Basic Punch
- Implemented anim-driven hitboxes with notify windows and per-attack hit registry.
- Knockback 100 on hit.
- Verified single-hit and no self-hit in PIE.
```

---

## P3. Block (hold Space)

**Goal:** Hold to reduce incoming damage by 40%. Some attacks break block via tag.

**Deliverables**

* `UBlockComponent` with `bIsBlocking`.
* Tags respected: `Attack.Unblockable` → ignore block; otherwise *Final = Base*(1-0.40)=60%\*.

**DoD**

* Holding Space reduces damage; releasing returns to normal. Unblockables ignore reduction.

**AI Agent – Steps**

1. Implement `UBlockComponent`. Expose `StartBlock()`, `StopBlock()`.
2. Hook into `UDamageCalculator` to query block state + tags.
3. Add simple block stance montage (optional).

**In‑Engine Setup**

* Bind IA\_Block\_Space\_Hold to `StartBlock` on pressed, `StopBlock` on released.

**Tests**

* Two attacks: `DA_Attack_Basic` (blockable) and a test `DA_Attack_Unblockable` (tagged).
* Verify damage 60% on blockable when holding; verify full on unblockable.

**Changelog**

```
## P3 – Block
- Added BlockComponent (40% reduction) with tag exceptions.
- Verified damage reduction and exceptions in PIE.
```

---

## P4. Parry + Vulnerability (charges) + optional i‑frames

**Goal:** Parry succeeds **only** if RMB within attacker’s *ParryWindow* notify. On success: target gains **Vulnerable** for 1s with **Charges** (=1 for parry). Blocked hits also consume charges (your rule).

**Deliverables**

* `UParryComponent` (listens for RMB input; plays a parry montage anytime, but only *succeeds* if the attacker has an active ParryWindow targeted at you).
* `UVulnerabilityComponent` with `(Duration, Charges, Multiplier)` and charge consumption on any incoming **damaging** hit, blocked or not.
* Optional: 0.2s i‑frames on parry success (toggleable bool).

**DoD**

* Enemy attack contains a ParryWindow notify. If you press RMB in that window → Vulnerability applied to enemy (Duration=1.0, Charges=1, Mult=8 default for your example) → next hit within time deals multiplied damage and consumes 1 charge.

**AI Agent – Steps**

1. **Parry Window:** Create `AN_ParryWindowStart/End` notifies placed in **enemy attack montages**.
2. **Shared Attack Context:** When enemy starts an attack, `UCombatComponent` creates an `FAttackContext` (Attacker, IntendedTarget, AttackData, UniqueID). Broadcast `OnParryWindowOpened(Context)` on notify.
3. **Player Parry Logic:** On RMB pressed, if a valid `Context` is currently parryable and within window → success.
4. **Vulnerability:** Implement charges and timer; consumption occurs on `OnDamaged` at the **defender** side (consumed by any damage, blocked or not).
5. **I‑Frames (optional):** On parry success, grant 0.2s damage immunity (flag in Health/Parry component).

**In‑Engine Setup**

* Add ParryWindow notifies to the enemy basic punch montage.
* Bind IA\_Parry\_RMB to `ParryComponent->TryParry()` (plays montage regardless, only marks success inside window).

**Tests**

* Enemy attacks. Time RMB within window → see Vulnerable indicator (debug print or UI). Hit immediately: 5 dmg × 8 = 40 dmg.
* Block then hit: still consumes a charge.
* Charges>1 test: give a debug ability that applies Vulnerable(Charges=2) and verify two hits consume both.

**Changelog**

```
## P4 – Parry & Vulnerability
- Implemented Parry with ParryWindow notifies and Vulnerability (duration+charges+multiplier).
- Optional 0.2s i-frames toggled ON by default.
- Verified 8x damage on next hit and charge consumption on blocked hits.
```

---

## P5. Heavy Punch Special (ragdoll, long recovery, wall bump bonus)

**Goal:** Special #1: on hit → 500 knockback with ragdoll, longer recovery on whiff. Extra 0.3s stagger + extra damage on wall impact.

**Deliverables**

* `DA_Attack_Heavy` with tags `Attack.Heavy|Attack.Blockable|Attack.Parryable`.
* Ragdoll activation on target, auto‑recover after \~0.7s.
* Wall‑bump detection.

**DoD**

* Land heavy: enemy ragdolls; on hitting a wall, add 0.3s stagger and small bonus damage; miss = long recovery (tunable section in montage).

**AI Agent – Steps**

1. Heavy montage with longer recovery section and cancel windows off.
2. On hit: `Target->SetSimulatePhysics(true)` for ragdoll or use Physical Animation Component blend.
3. Detect wall bump: monitor velocity + collision during ragdoll; if impact normal strength > threshold → apply extra stagger & damage once.
4. Ensure clean blend back (Get up anim or snap‑blend after time).

**In‑Engine Setup**

* Bind IA\_Heavy\_E to heavy attack request.

**Tests**

* Hit near a wall: confirm extra stagger & damage.
* Whiff: verify longer recovery prevents immediate mash.

**Changelog**

```
## P5 – Heavy Punch Special
- Heavy attack with ragdoll, wall-bump bonus (0.3s stagger + bonus dmg), long whiff recovery.
```

---

## P6. Stagger System + Light Poise

**Goal:** Distinguish **Stagger** (action lock) from Vulnerable. Add **Poise** to prevent infinite trading.

**Deliverables**

* `UStaggerComponent` (ApplyStagger(Duration), blocks actions, plays stagger anim).
* `Poise` in `UHealthComponent` or a small `UPoiseComponent` (MaxPoise, CurrentPoise, RegenRate).
* Attacks apply `PoiseDamage` from `UAttackDataAsset`.

**DoD**

* Repeated hits break poise → short stagger; vent/valve will also apply stagger later.

**AI Agent – Steps**

1. Implement Poise fields and decay over time.
2. On damage, subtract poise by AttackData.PoiseDamage. If <=0, trigger stagger (e.g., 0.6s), reset poise after recovery.
3. Add tag `Effect.Stagger` to effects that should stagger (vent/valve will use it later).

**In‑Engine Setup**

* Add stagger montage(s) to Player/Enemy.

**Tests**

* Chain jabs: after N hits, target staggers. Verify timer prevents action input.

**Changelog**

```
## P6 – Stagger & Poise
- Added Stagger component and light Poise system.
- Verified poise break triggers stagger and blocks actions temporarily.
```

---

## P7. Focus Mode Targeting + Interactables Framework + Vent + Valve

**Goal:** Hold **Q** to enter Focus: show candidates in 1000 range; **screen‑space directional selection** with a stable snap; release to trigger selected interactable. Implement **Vent** (one‑shot projectile stagger) and **Valve** (200 AoE + mage stagger).

**Deliverables**

* `ICombatInteractable` (Trigger(Instigator)).
* `UInteractableSensorComponent` (sphere overlap + LOS).
* `UTargetingComponent` (scoring: screen X/Y distance, angle from camera, world distance, last‑selected bias + hysteresis).
* `AInteractable_Vent`, `AInteractable_Valve` with their own behaviors.

**DoD**

* In Focus, objects glow; smallest mouse nudges switch selection predictably; releasing Q triggers behavior.

**AI Agent – Steps**

1. **Sensor:** maintain array of interactables within 1000 units & visible.
2. **Targeting Score (each tick in Focus):**
   `Score = A*ScreenDelta + B*AngleDelta + C*WorldDistance + D*LastSelectedBias`
   Choose lowest; add hysteresis so selection doesn’t flicker.
3. **VFX:** Outline or Niagara glow; stronger glow on selected.
4. **Vent:** Launch actor in preset direction; on hit any character → **1.0s Stagger**, then destroy. One‑shot.
5. **Valve:** Apply radial damage (200 radius). If target has tag `Archetype.Mage` → 1.0s Stagger.

**In‑Engine Setup**

* Create BP children for Vent/Valve for easy placement; set direction/cooldown on instances.

**Tests**

* Place 5–6 objects; enter Focus; nudge camera to switch; release to trigger. Confirm stagger/damage effects.

**Changelog**

```
## P7 – Focus & Interactables (Vent/Valve)
- Implemented Focus targeting and Interactables interface.
- Vent/Valve behaviors completed; verified glow, selection, and trigger-on-release.
```

---

## P8. Combat State + Smart Soft Lock Camera

**Goal:** Auto soft‑lock **when combat starts** (enemy perceives player); **unlock** if player **forces** camera away.

**Deliverables**

* `UCombatStateComponent` on both sides: `bInCombat`.
* Enter combat when enemy detects player (simple distance/LOS or perception).
* `UCameraLockComponent` (or logic in PlayerCameraManager): when `bInCombat` → nudge camera framing to keep enemy on screen; compute **unlock** if mouse turn speed exceeds threshold for short duration.

**DoD**

* Approach enemy → camera softly centers both. Rapidly swing camera away → unlock (free look). Re‑enter proximity → relock.

**AI Agent – Steps**

1. Add Perception or simple LOS + range check on enemy; on success → broadcast `OnCombatStart(Player, Enemy)`.
2. Player camera: add spring arm yaw bias towards enemy; clamp max offset; interpolate (no hard snap).
3. Unlock rule: if input yaw rate > threshold for N frames, disable soft lock until re‑entry.

**In‑Engine Setup**

* Tune arm length, socket offset for over‑shoulder readability.

**Tests**

* Enter enemy range: lock engages; rotate mouse fast: lock drops; step away & re‑engage.

**Changelog**

```
## P8 – Smart Soft Lock
- Combat state driven soft lock-on, with user-forced unlock.
- Verified engage/disengage behavior.
```

---

## P9. Enemy AI (BT/BB): Basic → Combos → Specials → Interactables

**Goal:** Single enemy archetype with BT/BB using your behaviors:

* Always active (no patrol).
* Basic punch, block/parry capabilities.
* **Catch Special** after 5s of kiting.
* **Soul Attack** (unblockable/unparryable, 10s CD, causes stagger).
* Combos (2–3, rare 4), feints (rare), environment usage.

**Deliverables**

* Blackboard keys: `TargetActor, DistToTarget, LOS, IsTargetVulnerable, TimePlayerKiting, InteractableBest, SoulReady, ComboPhase, WantParry, WantBlock`.
* BT Tasks/Services:

  * **Services:** Update player kiting timer (distance > mid‑range & no hits/abilities by player). Evaluate interactables (simple heuristic or EQS).
  * **Tasks:** `BTTask_ExecuteAttackTag`, `BTTask_Block`, `BTTask_Parry`, `BTTask_UseInteractable`, `BTTask_SoulAttack`, `BTTask_CatchSpecial`.
* Data‑driven **ComboModule** selection (patterns from your spec).

**DoD**

* Enemy engages on sight; uses combos; punishes Vulnerable; uses Vent/Valve opportunistically; performs Catch Special if you kite > 5s; Soul Attack pierces block/parry on 10s CD.

**AI Agent – Steps**

1. Create BB & BT scaffolding; bind Tasks to `UCombatComponent` calls with tags/data assets.
2. **Parry/Block**: Listen for player LMB spam rate; parry occasionally in windows; otherwise block.
3. **Combos:** Implement 3 data‑driven patterns: Pressure, Guard Crusher, Whiff Punish; add rare 4th‑hit chain.
4. **Interactables:** Query from `UInteractableSensorComponent` (enemy version) + LOS; if score high & cooldowns ok → `UseInteractable`.
5. **Catch Special:** If `TimePlayerKiting > 5s` and distance criteria → Trigger grab & slam montage (root motion).

**In‑Engine Setup**

* Place enemy in arena; set Attack Data Assets on enemy CombatComponent; configure AIController to run BT on BeginPlay.

**Tests**

* Verify all behaviors fire under conditions; print debug states; tune thresholds.

**Changelog**

```
## P9 – Enemy AI Core
- BT/BB implemented with combos, parry/block reactions, Soul Attack, Catch Special, and interactable usage.
- Verified behaviors in 1v1 arena.
```

---

## P10. Polish & Debug Utilities

**Goal:** Make it feel great and easy to tune.

**Deliverables**

* **Hit‑pause** (light for jab, heavier for heavy).
* **Camera shake** & subtle FOV kick on big hits.
* **Motion Warping** hooks for extended reach animations (keeps hand sphere honest).
* **On‑screen debug HUD** toggles for: tags, poise, stagger, vulnerability charges/time, AI state.
* **Tuning console vars** (e.g., `cm.VulnMult`, `cm.PoiseRegen`, `cm.LockStrength`).

**DoD**

* Responsive feel, easy to iterate with cvars and HUD.

**AI Agent – Steps**

1. Add a small `UDebugHUDSubsystem` (or cheat manager) to draw states.
2. Wire hit‑pause to AttackData asset values.
3. Add motion warping to jab/lean attacks.

**In‑Engine Setup**

* Keybind tilde‑menu or hotkeys to toggle debug.

**Tests**

* Validate feel changes when tweaking cvars live.

**Changelog**

```
## P10 – Polish & Debug
- Added hit-pause, shakes, motion warping, and debug HUD/cvars.
```

---

# Global Implementation Rules (for the AI agent)

* **No code duplication:** All hit processing funnels through `UCombatComponent` + `UDamageCalculator`.
* **Data first:** Attacks & abilities are **Data Assets**; BT tasks reference **tags** not hardcoded functions.
* **Interfaces everywhere:** `ICombatant` (get components, team), `ICombatInteractable` (Trigger).
* **Notify relay:** Centralize all Anim Notify handling in a single component (e.g., `UAnimEventRelayComponent`) that fires delegates to the right systems.
* **Gameplay Tags drive rules** (Blockable/Parryable/Unblockable/Unparryable, Effect.Stagger, State.Vulnerable, Archetype.Mage).
* **Testing cadence:** After each phase, run the **Tests** below and append the **Changelog** entry.

---

# Versioning & Changelog Practice

Create/maintain **`/Docs/changelog.md`**. After every phase, add a **Session Summary**:

**Template**

```
# Session: <YYYY-MM-DD HH:MM> – Phase PX

## Changes
- <bulleted list>

## Tests Performed
- <steps and outcomes>

## Tuning Values
- <any numbers tweaked>

## Known Issues / Next
- <bulleted list>
```

**Commit message convention**

```
PX: <short description>  // e.g., P4: Parry & Vulnerability with charges and i-frames
```

---

# In‑Engine Setup Cheatsheet (recurring)

* **Input:** Enhanced Input only. Avoid legacy binds.
* **Collision presets:** Characters ignore their own `Hitbox`. Hitboxes overlap `Pawn`.
* **Blueprint exposure:** All tunables `EditAnywhere` + `Category`.
* **Animations:** Name consistently: `AM_Player_Jab`, `AM_Enemy_Jab`, `NS_AttackWindow`, `NS_ParryWindow`.
* **Tags:** Add all to ini and verify in Gameplay Tags settings (hot reload sometimes misses new tags; restart editor if needed).
* **Physics:** For ragdoll, lock out movement input while simulating, then blend back.

---

## Numbers to start (you can tune at P10)

* Jab: 5 dmg, 100 knockback.
* Parry: Vulnerable(Charges=1, Duration=1.0s, Multiplier=8). i‑frames on success: 0.2s (toggleable).
* Block: 40% reduction → chip = 60%.
* Heavy: 500 knockback + ragdoll \~0.7s; wall bump → +0.3s stagger + bonus dmg (e.g., +5).
* Soul attack: 10s CD, `Attack.Unblockable|Attack.Unparryable`, applies stagger.
* Poise: start 100, jab deals 20, heavy 50, regen 15/s after 1.5s no damage.
* Focus range: 1000; selection hysteresis 0.2.

---

## What the AI agent should **not** over‑engineer

* No GAS.
* Keep BT tasks thin; push logic into components.
* No complex prediction windows; use notifies + simple contexts.
* No multi‑target systems; it’s 1v1.

---

## Ready to build

If you follow **P0 → P10** in order—coding exactly what’s listed, running the **Tests** after each phase, and logging into **changelog.md**—you’ll have a solid, playable vertical slice with your systems layered safely and cleanly for further expansion.

When you finish **P2–P4**, ping me with any feel issues (e.g., if 60% chip feels too punishing). I can then provide targeted tuning tables and suggested montage timings without changing the architecture.

